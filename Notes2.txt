






from werkzeug.exceptions import BadRequest

@app.errorhandler(BadRequest)
def handle_bad_request(e):
    """Handle malformed requests gracefully"""
    return 'Bad Request', 400

# Add to your Flask app configuration
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max-limit


@echo off

REM === HIDDEN OPTIONS ===
REM Run completely hidden (no window)
REM start "" pythonw.exe sync_lyrics.py

REM Run hidden with different working directory
REM start "" /D "C:\YourPath" pythonw.exe sync_lyrics.py

REM === CMD PROMPT OPTIONS ===
REM Run with basic cmd prompt
REM python sync_lyrics.py

REM Run minimized cmd prompt
REM start /min cmd /c python sync_lyrics.py

REM Run cmd with custom title
REM start "SyncLyrics" cmd /c python sync_lyrics.py

REM === WINDOWS TERMINAL OPTIONS ===
REM Run with Terminal and title
REM wt.exe --title "SyncLyrics" python sync_lyrics.py

REM Run Terminal minimized
REM wt.exe --title "SyncLyrics" --window-state minimized python sync_lyrics.py

REM Run Terminal maximized
REM wt.exe --title "SyncLyrics" --maximized python sync_lyrics.py

REM Run Terminal with specific profile
REM wt.exe --profile "Python" python sync_lyrics.py

REM Run Terminal with specific size and position
REM wt.exe --title "SyncLyrics" --size 120,30 --position 50,50 python sync_lyrics.py

REM === PYTHON OPTIONS ===
REM Run with specific Python version
REM py -3.9 sync_lyrics.py

REM Run with debug mode
REM python -d sync_lyrics.py

REM Run with optimizations
REM python -O sync_lyrics.py

REM Run with specific environment variables
REM set PYTHONPATH=path/to/libs && python sync_lyrics.py

REM === ADVANCED OPTIONS ===
REM Run with low priority
REM start /low "" pythonw.exe sync_lyrics.py

REM Run with high priority
REM start /high "" pythonw.exe sync_lyrics.py

REM Run and redirect output to file
REM python sync_lyrics.py > output.log 2>&1

REM Run and append output to log file
REM python sync_lyrics.py >> app.log 2>&1


Some useful Windows Terminal (wt.exe) parameters:
--title: Set window title
--window-state: minimized/maximized/normal
--size: Window size (columns,rows)
--position: Window position (X,Y)
--tabColor: Set tab color
--profile: Use specific terminal profile
--focus: Bring window to front
Some useful CMD parameters:
/c: Run command and close
/k: Run command and keep open
/min: Start minimized
/max: Start maximized
/b: Start without window (background)
Some useful Python parameters:
-d: Debug mode
-O: Optimize
-v: Verbose
-m: Run module
-c: Run command
-i: Interactive mode


Yes, that's a successful test! The Spotify API is working correctly - it's authenticating and retrieving track data. Let's plan the next steps:

1. **Add Album Art Display**
First, let's modify the UI to show album art and track info. We'll update index.html:

```html:resources/templates/index.html
{% extends "base.html" %}
{% block scripts %}
    <script src="{{ url_for('static', filename='js/lyrics.js')}}"> </script>
{% endblock %}
{% block content %}
    <div class="track-info">
        <img id="album-art" class="album-art" src="" alt="Album Art">
        <div class="track-details">
            <div id="track-title" class="track-title"></div>
            <div id="track-artist" class="track-artist"></div>
        </div>
    </div>
    <div id="lyrics" class="lyrics-container">
        <div id="prev-2" class="lyric-line far-previous"></div>
        <div id="prev-1" class="lyric-line previous"></div>
        <div id="current" class="lyric-line current"></div>
        <div id="next-1" class="lyric-line next"></div>
        <div id="next-2" class="lyric-line far-next"></div>
        <div id="next-3" class="lyric-line far-next"></div>
    </div>
{% endblock %}
```

2. **Add CSS for New Elements**
Add to base.css:

```css
/* Track info styling */
.track-info {
    position: fixed;
    top: 20px;
    left: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    background: rgba(0, 0, 0, 0.3);
    padding: 10px;
    border-radius: 10px;
    backdrop-filter: blur(10px);
}

.album-art {
    width: 60px;
    height: 60px;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.track-details {
    color: #fff;
}

.track-title {
    font-weight: 500;
    font-size: 1.1em;
}

.track-artist {
    opacity: 0.8;
    font-size: 0.9em;
}
```

3. **Create Backend Route**
Create a new route in your Flask app:

```python
@app.route('/current-track')
def current_track():
    spotify = SpotifyAPI()
    track = spotify.get_current_track()
    return jsonify(track if track else {"error": "No track playing"})
```

4. **Update lyrics.js**
Add track info fetching:

```javascript
async function updateTrackInfo() {
    try {
        let response = await fetch('/current-track');
        let track = await response.json();
        
        if (track && !track.error) {
            document.getElementById('album-art').src = track.album_art;
            document.getElementById('track-title').textContent = track.title;
            document.getElementById('track-artist').textContent = track.artist;
        }
    } catch (error) {
        console.error('Error fetching track info:', error);
    }
}

// Add to main function
```reference:resources/js/lyrics.js
startLine: 75
endLine: 86
```
// Update to include track info
async function main() {
    document.body.style.background = `linear-gradient(135deg, ${currentColors[0]} 0%, ${currentColors[1]} 100%)`;
    
    while(true) {
        await Promise.all([
            getLyrics(),
            updateTrackInfo()
        ]);
        await sleep(400);
    }
}
```

Would you like me to:
1. Show how to implement any specific part in more detail?
2. Add progress bar functionality?
3. Add click-to-open-in-Spotify functionality?

---

Notes2.txt

Project: SyncLyrics - Enhanced Lyrics Fetching System

Overview:

The SyncLyrics project aims to provide a robust and efficient system for fetching and displaying synchronized lyrics for currently playing songs.  The project utilizes multiple providers (LRCLib, NetEase, Spotify, Genius) to maximize lyrics availability and prioritizes synced lyrics for a better user experience.

Current State:

The core functionality of fetching lyrics from different providers, assessing their quality, and displaying them is implemented and generally functional.  The project utilizes a provider priority system, a local lyrics database for caching, and a configurable timing mechanism.

Key Improvements:

* Synced Lyrics Prioritization: The system prioritizes synced lyrics from all providers and falls back to unsynced lyrics only if no synced lyrics are found.
* Configurable Timing: The lyric display timing is now configurable through `SYNC_SETTINGS` in `config.py`, allowing for latency compensation and buffer size adjustments.
* "Next Line" Timing Algorithm:  The project now uses a "next line" approach for lyric timing, which can provide smoother transitions and a more natural feel.
* Robust Error Handling (Partially Implemented):  Error handling and retry logic have been improved, particularly in the LRCLib provider.

Outstanding Issues and Recommendations:

1. Provider Reliability:

* LRCLibProvider:  While improved, occasional "coroutine was expected" errors still occur.  Double-check all `await` calls and ensure the `retry_async` helper is used correctly.  Investigate the 404 errors and verify the LRCLib API endpoint and parameters.
* SpotifyProvider:  Similar "coroutine was expected" errors can occur.  Thoroughly review all `await` calls in `get_lyrics`, `_get_track_id_from_web_api`, and `_get_lyrics_for_track`.  Implement more specific exception handling in `fetch_with_retry` and other methods.  Implement a fallback to directly query the Spotify API if other methods fail.
* NetEaseProvider:  While generally functional, the provider might not find lyrics for all songs.  Experiment with different search queries and consider regional restrictions.  Add provider-specific error handling.
* General Provider Recommendations:  Add more detailed logging within each provider to track API requests, responses, and errors.  Create minimal test cases to reproduce and isolate provider issues.

2. Lyric Timing and Synchronization:

* Position Data Accuracy: The accuracy of `state.current_song_data["position"]` is crucial.  Investigate and improve the `get_current_song_meta_data()` function in `system_utils.py`.  Consider event-driven updates if possible.
* Edge Case Handling (Early in Song): Add a check in `get_timed_lyrics_previous_and_next` to handle the case where the current time is significantly before the first lyric timestamp.
* User Configuration (Optional):  Consider adding a setting to allow users to choose between the "next line" approach and the binary search method for lyric timing.

3. Code Improvements:

* SpotifyProvider: Make `_track_successful_method` synchronous.
* Remove Unused Code: Remove the `_save_to_cache` function.
* Cache Persistence (Optional): Implement saving and loading the cache to/from a file for improved startup performance.

Next Steps:

1. Focus on resolving the remaining provider errors, particularly the "coroutine was expected" errors and the LRCLib 404 errors.
2. Investigate and improve the accuracy of the song position data.
3. Implement the remaining code improvements (Spotify `_track_successful_method`, unused code removal).
4. Thoroughly test the application with various songs and providers, paying close attention to synchronization and error handling.
5. Consider implementing optional features like cache persistence and user configuration for timing methods.
